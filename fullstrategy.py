"""
Streamlit app + backtester for RSI+EMA50+ADX+ATR strategy

This single-file app downloads data (yfinance), computes indicators, runs backtest and shows results.
Includes fixes for Streamlit Cloud / yfinance 1D array issues by coercing series to pandas Series and squeezing arrays.

Run locally: streamlit run app.py

Deploy to Streamlit Cloud: push to GitHub (this file as app.py + requirements.txt) and connect repo in Streamlit Cloud dashboard.

Author: Generated by ChatGPT (assistant)
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from math import floor
import matplotlib.pyplot as plt
import io
import base64

st.set_page_config(layout='wide', page_title='Swing Strategy Backtester')

# -------------------------------
# Utility: ensure series are 1D
# -------------------------------
def to_1d_series(x, name=None):
    """Coerce input (DataFrame/ndarray/Series) to a pandas Series 1D.
    This avoids 'Data must be 1-dimensional' errors on Streamlit Cloud / yfinance.
    """
    if isinstance(x, pd.Series):
        s = x
    elif isinstance(x, pd.DataFrame):
        # if single-column DataFrame, squeeze
        if x.shape[1] == 1:
            s = x.iloc[:, 0]
        else:
            # cannot coerce multi-column -> try to pick first column
            s = x.iloc[:, 0]
    else:
        # numpy array or list
        arr = np.asarray(x)
        if arr.ndim == 1:
            s = pd.Series(arr)
        elif arr.ndim == 2 and arr.shape[1] == 1:
            s = pd.Series(arr.ravel())
        else:
            # fallback: flatten
            s = pd.Series(arr.ravel())
    if name is not None:
        s.name = name
    return s.astype(float)

# -------------------------------
# Indicators
# -------------------------------

def compute_rsi(series, period=14):
    s = to_1d_series(series, name='close')
    delta = s.diff()
    up = delta.clip(lower=0)
    down = -1 * delta.clip(upper=0)
    ma_up = up.ewm(alpha=1/period, adjust=False).mean()
    ma_down = down.ewm(alpha=1/period, adjust=False).mean()
    rs = ma_up / ma_down
    rsi = 100 - (100 / (1 + rs))
    return rsi


def compute_atr(df, period=14):
    # ensure df columns are correct and 1D
    high = to_1d_series(df['High'], name='High')
    low = to_1d_series(df['Low'], name='Low')
    close = to_1d_series(df['Close'], name='Close')
    prev_close = close.shift(1)
    tr1 = high - low
    tr2 = (high - prev_close).abs()
    tr3 = (low - prev_close).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    atr = tr.ewm(alpha=1/period, adjust=False).mean()
    return atr


def compute_adx(df, period=14):
    high = to_1d_series(df['High'], name='High')
    low = to_1d_series(df['Low'], name='Low')
    close = to_1d_series(df['Close'], name='Close')
    prev_close = close.shift(1)

    tr1 = high - low
    tr2 = (high - prev_close).abs()
    tr3 = (low - prev_close).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    up_move = high.diff()
    down_move = -low.diff()
    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0.0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0.0)

    tr_smooth = pd.Series(tr).ewm(alpha=1/period, adjust=False).mean()
    plus_smooth = pd.Series(plus_dm).ewm(alpha=1/period, adjust=False).mean()
    minus_smooth = pd.Series(minus_dm).ewm(alpha=1/period, adjust=False).mean()

    plus_di = 100 * (plus_smooth / tr_smooth)
    minus_di = 100 * (minus_smooth / tr_smooth)
    dx = (abs(plus_di - minus_di) / (plus_di + minus_di).replace(0, np.nan)) * 100
    adx = dx.ewm(alpha=1/period, adjust=False).mean()
    adx.index = df.index
    return adx.fillna(0)


def compute_stoch_rsi(rsi_series, period=14):
    rs = to_1d_series(rsi_series, name='RSI')
    min_rsi = rs.rolling(window=period, min_periods=1).min()
    max_rsi = rs.rolling(window=period, min_periods=1).max()
    denom = (max_rsi - min_rsi).replace(0, np.nan)
    stoch = (rs - min_rsi) / denom
    stoch = stoch.fillna(0)
    return stoch * 100

# -------------------------------
# Backtest engine (same rules as before)
# -------------------------------

def backtest(df, params):
    df = df.copy()
    # ensure numeric columns
    for col in ['Open', 'High', 'Low', 'Close', 'Volume']:
        if col in df.columns:
            df[col] = to_1d_series(df[col], name=col)

    df['EMA'] = df['Close'].ewm(span=params['ema_period'], adjust=False).mean()
    df['RSI'] = compute_rsi(df['Close'], period=params['rsi_period'])
    df['ATR'] = compute_atr(df, period=params['atr_period'])
    df['ADX'] = compute_adx(df, period=params['adx_period'])
    df['StochRSI'] = compute_stoch_rsi(df['RSI'], period=params['rsi_period'])
    df['Vol20'] = df['Volume'].rolling(window=20, min_periods=1).mean()

    trades = []
    equity = params['capital']
    equity_curve = []
    position = None

    for i in range(1, len(df)):
        today = df.index[i]
        row = df.iloc[i]
        prev = df.iloc[i-1]

        if position is None:
            equity_curve.append({'Date': today, 'Equity': equity})
        else:
            market_value = position['shares'] * row['Close']
            cur_equity = equity - position['cost_basis'] + market_value
            equity_curve.append({'Date': today, 'Equity': cur_equity})

        if position is None:
            signal_day = prev
            cond_trend = signal_day['Close'] > signal_day['EMA']
            cond_rsi = signal_day['RSI'] <= params['rsi_thresh']
            cond_adx = signal_day['ADX'] > params['adx_thresh']
            cond_vol = signal_day['Volume'] >= (signal_day['Vol20'] * params['vol_factor'])

            if cond_trend and cond_rsi and cond_adx and cond_vol:
                entry_price_raw = row['Open']
                entry_price = entry_price_raw * (1 + params['slippage_pct'])
                atr = signal_day['ATR'] if not np.isnan(signal_day['ATR']) else row['ATR']
                stop_price = entry_price - params['atr_mult_stop'] * atr
                target_price = entry_price * (1 + params['target_pct'])

                risk_amount = params['capital'] * params['risk_pct']
                stop_distance = entry_price - stop_price
                if stop_distance <= 0:
                    continue
                shares = floor(risk_amount / stop_distance)
                if shares <= 0:
                    continue

                cost_basis = shares * entry_price
                if cost_basis > params.get('max_exposure_pct', 0.1) * params['capital']:
                    max_cost = params.get('max_exposure_pct', 0.1) * params['capital']
                    shares = floor(max_cost / entry_price)
                    if shares <= 0:
                        continue
                    cost_basis = shares * entry_price

                position = {
                    'entry_date': today,
                    'entry_price': entry_price,
                    'shares': shares,
                    'stop_price': stop_price,
                    'target_price': target_price,
                    'atr': atr,
                    'days_held': 0,
                    'cost_basis': cost_basis,
                    'activated_trailing': False,
                    'highest_price': entry_price
                }
                equity -= params['commission_pct'] * cost_basis

        else:
            position['days_held'] += 1
            high = row['High']
            low = row['Low']
            close = row['Close']
            atr = row['ATR'] if not np.isnan(row['ATR']) else position['atr']

            if high > position['highest_price']:
                position['highest_price'] = high

            if (not position['activated_trailing']) and (position['highest_price'] >= position['entry_price'] + params['trailing_activation_mult'] * position['atr']):
                position['stop_price'] = max(position['stop_price'], position['entry_price'] + params['trailing_initial_mult'] * position['atr'])
                position['activated_trailing'] = True

            if position['activated_trailing']:
                new_stop = position['highest_price'] - params['trailing_active_mult'] * atr
                position['stop_price'] = max(position['stop_price'], new_stop)

            exit_reason = None
            exit_price = None

            if low <= position['stop_price']:
                exit_price = position['stop_price'] * (1 - params['slippage_pct'])
                exit_reason = 'stop'
            elif high >= position['target_price']:
                exit_price = position['target_price'] * (1 - params['slippage_pct'])
                exit_reason = 'target'
            elif position['days_held'] >= params['max_days']:
                exit_price = close * (1 - params['slippage_pct'])
                exit_reason = 'time'
            else:
                if close < row['EMA'] and params.get('exit_on_ema_break', False):
                    exit_price = close * (1 - params['slippage_pct'])
                    exit_reason = 'ema_break'

            if exit_reason is not None:
                proceeds = position['shares'] * exit_price
                pnl = proceeds - position['cost_basis']
                ret_pct = pnl / position['cost_basis']
                equity += proceeds
                equity -= params['commission_pct'] * proceeds

                trades.append({
                    'entry_date': position['entry_date'],
                    'entry_price': position['entry_price'],
                    'shares': position['shares'],
                    'stop_price': position['stop_price'],
                    'target_price': position['target_price'],
                    'exit_date': today,
                    'exit_price': exit_price,
                    'exit_reason': exit_reason,
                    'days_held': position['days_held'],
                    'pnl': pnl,
                    'return_pct': ret_pct
                })
                position = None

    eq_df = pd.DataFrame(equity_curve).set_index('Date')
    eq_df = eq_df.sort_index()
    trades_df = pd.DataFrame(trades)
    metrics = compute_metrics(eq_df, trades_df, params['capital'])
    return trades_df, eq_df, metrics

# -------------------------------
# Metrics
# -------------------------------

def compute_metrics(equity_df, trades_df, starting_capital):
    metrics = {}
    if equity_df.empty:
        return metrics
    equity_df = equity_df.sort_index()
    equity_series = equity_df['Equity']
    returns = equity_series.pct_change().fillna(0)
    days = (equity_df.index[-1] - equity_df.index[0]).days
    years = days / 365.25 if days > 0 else 1
    ending = equity_series.iloc[-1]
    cagr = (ending / starting_capital) ** (1 / years) - 1 if years > 0 else 0
    sharpe = (returns.mean() / returns.std()) * np.sqrt(252) if returns.std() != 0 else np.nan
    roll_max = equity_series.cummax()
    drawdown = (equity_series - roll_max) / roll_max
    max_dd = drawdown.min()
    wins = trades_df[trades_df['pnl'] > 0]
    losses = trades_df[trades_df['pnl'] <= 0]
    win_rate = len(wins) / len(trades_df) if len(trades_df) > 0 else np.nan
    avg_win = wins['pnl'].mean() if not wins.empty else 0
    avg_loss = losses['pnl'].mean() if not losses.empty else 0
    avg_return = trades_df['return_pct'].mean() if not trades_df.empty else 0
    expectancy = win_rate * (wins['pnl'].mean() if not wins.empty else 0) - (1 - win_rate) * (abs(losses['pnl'].mean()) if not losses.empty else 0)
    metrics.update({
        'cagr': cagr,
        'sharpe': sharpe,
        'max_drawdown': max_dd,
        'n_trades': len(trades_df),
        'win_rate': win_rate,
        'avg_win': avg_win,
        'avg_loss': avg_loss,
        'avg_return_per_trade': avg_return,
        'expectancy': expectancy,
        'ending_equity': ending
    })
    return metrics

# -------------------------------
# Streamlit UI
# -------------------------------

st.title('Swing Strategy Backtester — RSI+EMA50+ADX+ATR')
with st.sidebar:
    ticker = st.text_input('Ticker (yfinance)', value='AAPL')
    start = st.date_input('Start date', value=pd.to_datetime('2018-01-01'))
    end = st.date_input('End date', value=pd.to_datetime(pd.Timestamp.today().date()))
    capital = st.number_input('Starting capital', value=100000.0, step=1000.0)
    risk = st.number_input('Risk per trade (fraction)', value=0.01, step=0.001, format='%.4f')
    slippage = st.number_input('Slippage (fraction)', value=0.001, step=0.0005, format='%.4f')
    commission = st.number_input('Commission (fraction)', value=0.0005, step=0.0001, format='%.5f')
    max_days = st.number_input('Max days per trade', value=30, step=1)
    run_btn = st.button('Run backtest')

# default params
params = {
    'rsi_period': 14,
    'rsi_thresh': 35,
    'ema_period': 50,
    'adx_period': 14,
    'adx_thresh': 18,
    'atr_period': 14,
    'atr_mult_stop': 1.5,
    'entry_at_next_open': True,
    'target_pct': 0.06,
    'max_days': int(max_days),
    'trailing_activation_mult': 2.0,
    'trailing_initial_mult': 0.5,
    'trailing_active_mult': 1.0,
    'risk_pct': float(risk),
    'capital': float(capital),
    'slippage_pct': float(slippage),
    'commission_pct': float(commission),
    'vol_factor': 0.7,
    'max_exposure_pct': 0.1,
    'exit_on_ema_break': False,
}

if run_btn:
    with st.spinner('Downloading data...'):
        # workaround: disable caching on yfinance in Streamlit Cloud by re-downloading each run
        data = yf.download(ticker, start=str(start), end=str(end), progress=False, threads=False)
    if data.empty:
        st.error('No data. Check ticker or date range. On Streamlit Cloud, yfinance may have timezone/caching issues — try a shorter range or different ticker.')
    else:
        st.success('Data downloaded — running backtest')
        trades_df, eq_df, metrics = backtest(data, params)

        st.subheader('Metrics')
        st.write(metrics)

        col1, col2 = st.columns([2, 1])
        with col1:
            st.subheader('Equity Curve')
            if not eq_df.empty:
                fig, ax = plt.subplots(figsize=(10, 4))
                ax.plot(eq_df.index, eq_df['Equity'])
                ax.set_xlabel('Date')
                ax.set_ylabel('Equity')
                ax.grid(True)
                st.pyplot(fig)
        with col2:
            st.subheader('Trades')
            if not trades_df.empty:
                st.dataframe(trades_df.sort_values('entry_date', ascending=False).reset_index(drop=True))

        # Download buttons
        if not trades_df.empty:
            csv = trades_df.to_csv(index=False).encode('utf-8')
            st.download_button('Download trades CSV', data=csv, file_name=f'trades_{ticker}.csv', mime='text/csv')
        if not eq_df.empty:
            csv2 = eq_df.to_csv().encode('utf-8')
            st.download_button('Download equity CSV', data=csv2, file_name=f'equity_{ticker}.csv', mime='text/csv')

        st.info('If you hit the Streamlit Cloud yfinance shape error, this app coerces arrays to 1D. If you still see issues, try toggling threads=False or testing a different ticker/date-range.')
